print('Created product_dimenstion')
# The following R code retrieves data from a SQLite database using the 'dbGetQuery' function.
# It executes a SQL query on the SQLite database connection 'dbConnSqlite'.
# The query selects two columns from the 'product' table and assigns aliases to them.
# The 'pid' column is aliased as 'product_id', and the 'p_name' column is aliased as 'product_name'.
local.sql.product.Query <-
dbGetQuery(dbConnSqlite,
"SELECT pid as product_id, p_name as product_name FROM product;")
# The first line executes an SQL query on the MySQL database using the 'dbExecute' function.
# It appears to execute the SQL query defined in 'remote.sql.product.Query' on the database.
dbExecute(dbConnMySQL, remote.sql.product.Query)
# It seems to write data from 'local.sql.product.Query' to a table named 'product_dimension' in the database.
# The 'append=TRUE' parameter indicates that data should be appended to the table if it already exists.
# The 'row.names = FALSE' parameter suggests that row names should not be included in the table.
dbWriteTable(
dbConnMySQL,
"product_dimension",
local.sql.product.Query,
append = TRUE,
row.names = FALSE
)
# This SQL query creates a table named 'sales_facts' in the database if it doesn't already exist.
# The table is intended to store sales-related information with various fields.
dbExecute(
dbConnMySQL,
"CREATE TABLE IF NOT EXISTS sales_facts (
sales_fact_id INT PRIMARY KEY AUTO_INCREMENT,
date_id INT,
reps_key INT,
product_key INT,
year INT,
quarter INT,
total_sales_amount DECIMAL(10, 2),
total_units_sold INT,
FOREIGN KEY (date_id) REFERENCES date_dimension(date_id),
FOREIGN KEY (reps_key) REFERENCES reps_dimension(reps_key),
FOREIGN KEY (product_key) REFERENCES product_dimension(product_key)
);"
)
print('Created sales_facts')
# This code executes an SQL query using the 'dbExecute' function to create a table named 'sales_dimension'.
# The 'IF NOT EXISTS' clause ensures that the table is only created if it doesn't already exist.
dbExecute(
dbConnMySQL,
"CREATE TABLE IF NOT EXISTS sales_dimension (
sales_key INTEGER PRIMARY KEY AUTO_INCREMENT,
sid INTEGER,
date DATE NOT NULL,
pid INTEGER,
quantity INTEGER NOT NULL,
sales_amt REAL NOT NULL,
rid VARCHAR(7) NOT NULL
);"
)
print('Created sales_dimension')
# The following R code involves data retrieval from a SQLite database and data writing to a MySQL database.
# The first line fetches data from the SQLite database using the 'dbGetQuery' function.
# It executes an SQL query on the SQLite database connected as 'dbConnSqlite'.
df.sales_dim <-
dbGetQuery(dbConnSqlite,
"SELECT sid, date, pid, quantity, sales_amt, rid FROM sales;")
# The line writes data to a table in the MySQL database using the 'dbWriteTable' function.
# It writes the data stored in 'df.sales_dim' to a table named 'sales_dimension' in the MySQL database.
dbWriteTable(
dbConnMySQL,
"sales_dimension",
df.sales_dim,
append = T,
row.names = F
)
# The following SQL query inserts data into a table named 'sales_facts' in a MySQL database using a database connection 'dbConnMySQL'.
# It combines data from various dimensions (date_dimension, product_dimension, and reps_dimension) and aggregates sales-related information.
dbExecute(
dbConnMySQL,
"INSERT INTO sales_facts (date_id, reps_key, product_key, year, quarter, total_sales_amount, total_units_sold)
SELECT
dd.date_id,
rd.reps_key,
pd.product_key,
dd.year,
dd.quarter,
SUM(s.sales_amt) AS total_sales_amount,
SUM(s.quantity) AS total_units_sold
FROM
sales_dimension s
JOIN
date_dimension dd ON dd.date = s.date
JOIN
product_dimension pd ON pd.product_id = s.pid
JOIN
reps_dimension rd ON rd.rep_id = s.rid
GROUP BY
dd.date_id, rd.reps_key;"
)
print('Inserted into sales_facts')
# This SQL query is intended to create a table named 'rep_facts' in a MySQL database if it doesn't already exist.
dbExecute(
dbConnMySQL,
"CREATE TABLE IF NOT EXISTS rep_facts (
rep_fact_id INTEGER PRIMARY KEY AUTO_INCREMENT,
rep_name VARCHAR(255),
rep_id VARCHAR(7),
total_sold DECIMAL(10, 2),
year INTEGER,
quarter INTEGER,
product_name VARCHAR(255),
total_sold_per_product DECIMAL(10, 2)
);
"
)
print('Created rep_facts')
# Insert aggregated sales data into 'rep_facts' table
# This query combines information from various dimensions (sales, date, product, reps)
# and calculates the total sales and total sales per product, grouped by representative name,
# year, quarter, and product name. The result is stored in the 'rep_facts' table.
dbExecute(
dbConnMySQL,
"INSERT INTO rep_facts (rep_name, rep_id, total_sold, year, quarter, product_name, total_sold_per_product)
SELECT
CONCAT(rd.first_name, ' ', rd.last_name) AS rep_name,
rd.rep_id,
SUM(sd.sales_amt) AS total_sold,
dd.year,
dd.quarter,
pd.product_name,
SUM(sd.sales_amt) AS total_sold_per_product
FROM
sales_dimension sd
JOIN
date_dimension dd ON dd.date = sd.date
JOIN
product_dimension pd ON pd.product_id = sd.pid
JOIN
reps_dimension rd ON rd.rep_id = sd.rid
GROUP BY
rd.first_name, rd.last_name, dd.year, dd.quarter, pd.product_name;"
)
print('Inserted into rep_facts')
# Extracts the total sales amount for each quarter in the year 2022 from the 'sales_facts' table.
# The result is stored in the 'total_sold' variable using the dbGetQuery function.
result <- dbGetQuery(
dbConnMySQL,
"SELECT
quarter,
SUM(total_sales_amount) AS total_sold
FROM
sales_facts
WHERE
year = 2022
GROUP BY
quarter;"
)
# This R code retrieves the total sales amount for the product 'Alaraphosol' in each quarter of the year 2021.
# It uses SQL queries to join relevant tables and aggregate the data by quarter.
result2 <- dbGetQuery(
dbConnMySQL,
"SELECT
sf.quarter,
SUM(sf.total_sales_amount) AS total_sold
FROM
sales_facts sf
JOIN
reps_dimension rd ON sf.reps_key = rd.reps_key
JOIN
product_dimension pd ON pd.product_key = sf.product_key
WHERE
sf.year = 2021 AND pd.product_name = 'Alaraphosol'
GROUP BY
sf.quarter;"
)
# This R code retrieves the total sales amount for the EMEA region in the year 2022
# By joining the sales facts, reps dimension, and date dimension tables in a MySQL database.
result3 <-
dbGetQuery(
dbConnMySQL,
"SELECT SUM(sf.total_sales_amount) AS total_sales_in_EMEA_2022
FROM sales_facts sf
JOIN reps_dimension rd ON sf.reps_key = rd.reps_key
JOIN date_dimension dd ON sf.date_id = dd.date_id
WHERE rd.territory = 'EMEA' -- assuming the reps_dimension table has a 'region_name' column
AND dd.year = 2022;"
)
# This R code retrieves the total sales for each sales representative in the year 2022 from a MySQL database and identifies the top-performing representative.
# It then limits the result to only the top-performing representative with the highest total sales.
result4 <- dbGetQuery(
dbConnMySQL,
"SELECT
rep_name,
SUM(total_sold) AS total_sales
FROM
rep_facts
WHERE
year = 2022
GROUP BY
rep_name
ORDER BY
total_sales DESC
LIMIT 1;"
)
# Disconnect from the SQLite database connection.
dbDisconnect(dbConnSqlite)
# Disconnect from the MySQL database connection.
dbDisconnect(dbConnMySQL)
print('Disconnected from SQLite!')
print('Disconnected from MySQL!')
}
main()
library(RSQLite)
library(XML)
################# Reps Data reading and writing to DB #####################
# Function to convert an XML 'rep' node to a dataframe row
reps_to_df <- function(rep_node) {
# Extract the 'rID' attribute
rID <- xmlGetAttr(rep_node, "rID")
# Extract elements inside the 'rep' node
first_name <- xmlValue(rep_node[["name"]][["first"]])
sur_name <- xmlValue(rep_node[["name"]][["sur"]])
territory <- xmlValue(rep_node[["territory"]])
commission <- as.numeric(xmlValue(rep_node[["commission"]]))
# Return as a one-row dataframe
data.frame(
rid = rID,
f_name = first_name,
s_name = sur_name,
territory = territory,
commission = commission,
stringsAsFactors = FALSE
)
}
get_reps_XML_dataframe <- function() {
reps.Data <- xmlParse("txn-xml/pharmaReps-F23.xml")
rep.Nodes <- getNodeSet(reps.Data, "//rep")
reps.DataFrame <- do.call(rbind, lapply(rep.Nodes, reps_to_df))
return (reps.DataFrame)
}
create_reps_schema <- function(con) {
create_table_sql <- "
CREATE TABLE IF NOT EXISTS reps (
rid VARCHAR(7) PRIMARY KEY,
f_name TEXT,
s_name TEXT,
territory TEXT,
commission REAL
);"
dbExecute(con, create_table_sql)
}
drop_reps_schema <- function(con) {
drop_table_sql <- "DROP TABLE IF EXISTS reps;"
dbExecute(con, drop_table_sql)
}
################# Product Data reading #####################
get_product_XML_dataframe <- function(product_xml_file_path) {
# Parse the XML file
xml_data <- xmlParse(product_xml_file_path)
# Extract product data from the XML
sale_nodes <- getNodeSet(xml_data, "//sale")
products <-
sapply(sale_nodes, function(node)
xmlValue(node[["product"]]))
# Create a dataframe for products with unique product names
product.DataFrame <-
data.frame(
pid = NA,
p_name = unique(products),
stringsAsFactors = FALSE
)
return (product.DataFrame)
}
create_product_schema <- function(con) {
create_table_sql <- "
CREATE TABLE IF NOT EXISTS product (
pid INTEGER PRIMARY KEY AUTOINCREMENT,
p_name TEXT NOT NULL);"
dbExecute(con, create_table_sql)
}
drop_product_schema <- function(con) {
drop_table_sql <- "DROP TABLE IF EXISTS product;"
dbExecute(con, drop_table_sql)
}
################# Customer Data reading #####################
get_customer_XML_dataframe <- function(product_xml_file_path) {
# Parse the XML file
xml_data <- xmlParse(product_xml_file_path)
# Extract transaction data from the XML
txn_nodes <- getNodeSet(xml_data, "//txn")
customers <-
sapply(txn_nodes, function(node)
xmlValue(node[["customer"]]))
countries <-
sapply(txn_nodes, function(node)
xmlValue(node[["country"]]))
# Create a dataframe for customers with unique customer names and their countries
customer_data <-
data.frame(c_name = customers,
country = countries,
stringsAsFactors = FALSE)
customer.DataFrame <- customer_data[!duplicated(customer_data),]
return (customer.DataFrame)
}
create_customer_schema <- function(con) {
create_table_sql <-
"CREATE TABLE IF NOT EXISTS customer (
cid INTEGER PRIMARY KEY AUTOINCREMENT,
c_name TEXT NOT NULL,
country TEXT
);"
dbExecute(con, create_table_sql)
}
drop_customer_schema <- function(con) {
drop_table_sql <- "DROP TABLE IF EXISTS customer;"
dbExecute(con, drop_table_sql)
}
################# Sales and Juntion Data reading #####################
get_sales_customername_dataframe <-
function(product.Dataframe,
product_xml_file_path) {
xml_data <- xmlParse(product_xml_file_path)
txn_nodes <- getNodeSet(xml_data, "//txn")
sales.cname.Dataframe <-
do.call(rbind, lapply(txn_nodes, function(txn) {
product.Name <- xmlValue(txn[['sale']][['product']])
pid.Value <- which(product.Dataframe$p_name == product.Name)
result <- data.frame(
date = as.character(as.Date(xmlValue(txn[["sale"]][["date"]]), format =
"%m/%d/%Y")),
pid = pid.Value,
quantity = as.integer(xmlValue(txn[["sale"]][["qty"]])),
sales_amt = as.numeric(xmlValue(txn[["sale"]][["total"]])),
txnid = as.integer(xmlGetAttr(txn, "txnID")),
rid = paste0('r', xmlGetAttr(txn, "repID")),
c_name = xmlValue(txn[["customer"]])
)
}))
return (sales.cname.Dataframe)
}
create_sales_schema <- function(con) {
create_table_sql <-
"CREATE TABLE IF NOT EXISTS sales (
sid INTEGER PRIMARY KEY AUTOINCREMENT,
date DATE NOT NULL,
pid INTEGER NOT NULL,
quantity INTEGER NOT NULL,
sales_amt REAL NOT NULL,
rid VARCHAR(7) NOT NULL
);"
dbExecute(con, create_table_sql)
}
drop_sales_schema <- function(con) {
drop_table_sql <- "DROP TABLE IF EXISTS sales;"
dbExecute(con, drop_table_sql)
}
################# get junction table #####################
get_junction_table <-
function(sales_cname.Dataframe,
customer.Dataframe) {
junction.Dataframe <- data.frame(matrix(ncol = 3, nrow = 0))
colnames(junction.Dataframe) <- c('txnid', 'sid', 'cid')
junction.Dataframe <-
do.call(rbind, lapply(1:nrow(sales_cname.Dataframe), function(dataframe.row) {
txnID <- sales_cname.Dataframe[dataframe.row, "txnid"]
sID <- sales_cname.Dataframe[dataframe.row, "sid"]
name <- sales_cname.Dataframe[dataframe.row, "c_name"]
cID <- which(customer.Dataframe$c_name == name)
result <-
data.frame(
txnid = txnID,
sid = sID,
cid = cID,
stringsAsFactors = FALSE
)
}))
return (junction.Dataframe)
}
create_sales_customer_junction_schema <- function(con) {
create_table_sql <-
"CREATE TABLE IF NOT EXISTS sales_customer_junction (
txnid INTEGER NOT NULL,
sid INTEGER,
cid INTEGER,
PRIMARY KEY(txnid,sid,cid),
CONSTRAINT fk_junction_sales_link FOREIGN KEY(sid) references sales(sid),
CONSTRAINT fk_junction_customer_link FOREIGN KEY(cid) references customer(cid)
);"
dbExecute(con, create_table_sql)
}
drop_sales_customer_junction_schema <- function(con) {
drop_table_sql <- "DROP TABLE IF EXISTS sales_customer_junction;"
dbExecute(con, drop_table_sql)
}
################# Main Method #####################
main <- function() {
cwd <- getwd()
dbFile <- "data.db"
pathToDb <- paste0(cwd,  .Platform$file.sep, dbFile)
# Create SQLite connection
con <- dbConnect(SQLite(), dbname = pathToDb)
print('Connected to SQLite')
### Dropping of all the relational schema if they already exists in the memory.
drop_reps_schema(con)
drop_customer_schema(con)
drop_product_schema(con)
drop_sales_schema(con)
drop_sales_customer_junction_schema(con)
### Creation of the relational schema in the passed sqlite database.
create_reps_schema(con)
create_product_schema(con)
create_customer_schema(con)
create_sales_schema(con)
create_sales_customer_junction_schema(con)
# Define the directory containing the XML files.
dir_path <- paste0(cwd,  .Platform$file.sep, "txn-xml")
# Getting list of files from the directory with the reg-ex pattern.
# As mentioned in the practicum the file names are checked with a particular pattern.
file_list <-
list.files(dir_path, pattern = "pharmaSalesTxn.*\\.xml", full.names = TRUE)
# Creating empty data frames to store values for the respective schemas.
## Empty data frame for sales representatives.
reps.Dataframe <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(reps.Dataframe) <-
c('rid', 'f_name', 's_name', 'territory', 'commission')
## As the sales file is different from others it is read at once using the fixed file path.
reps.Dataframe <- get_reps_XML_dataframe()
## Empty data frame for products schema that are sold by the pharma companies.
product.Dataframe <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(product.Dataframe) <- c('pid', 'p_name')
## Empty data frame for customers schema that buy particular products.
customer.Dataframe <- data.frame(matrix(ncol = 3, nrow = 0))
colnames(customer.Dataframe) <- c('cid', 'c_name', 'country')
## Empty data frame for sales schema that represents the sales transactions of products and their customer names.
sales.cname <- data.frame(matrix(ncol = 8, nrow = 0))
colnames(sales.cname) <-
c('sid',
'date',
'pid',
'quantity',
'sales_amt',
'txnid',
'rid',
'c_name')
# Parsing through list of files to fill the data in product and customer data frame.
for (file in file_list) {
print(paste0("Procesing Files for product & customer tables: ", file))
# Getting value of product from a method call using a local data frame field.
# It then appends the data to the main data frame using the rbind call.
product.Dataframe.SingleFile <- get_product_XML_dataframe(file)
product.Dataframe <-
rbind(product.Dataframe.SingleFile, product.Dataframe)
# Getting value of customers from a method call using a local data frame field.
# It then appends the data to the main data frame using the rbind call.
customer.Dataframe.SingleFile <- get_customer_XML_dataframe(file)
customer.Dataframe <-
rbind(customer.Dataframe.SingleFile, customer.Dataframe)
}
# Removing the duplicates from the product data frame.
# While parsing several files there might be same products purchased by different customers.
product.Dataframe <-
product.Dataframe[!duplicated(product.Dataframe), ]
# Assigning a surrogate key value to the product data frame before storing it in sqlite.
product.Dataframe$pid = 1:length(product.Dataframe$p_name)
# Removing the duplicates from the customer data frame.
customer.Dataframe <-
customer.Dataframe[!duplicated(customer.Dataframe), ]
# Assigning a surrogate key value to the customer data frame before storing it in sqlite.
customer.Dataframe$cid = 1:length(customer.Dataframe$c_name)
# Parsing the sales data frame using again similar for loop over the list of files.
# The sales schema needed values from the other tables like product for it's creation.
# So, sales table was created after complete processing of the other schemas.
for (file in file_list) {
print(paste0("Procesing Files for sales and junction tables: ", file))
sales.cname.Dataframe.SingleFile <-
get_sales_customername_dataframe(product.Dataframe, file)
sales.cname <- rbind(sales.cname.Dataframe.SingleFile, sales.cname)
}
sales.cname <- sales.cname[!duplicated(sales.cname), ]
sales.cname$sid = 1:length(sales.cname$pid)
junction.Dataframe <-
get_junction_table(sales.cname, customer.Dataframe)
sales.Dataframe <-
subset(sales.cname,
select = c('sid', 'date', 'pid', 'quantity', 'sales_amt', 'rid'))
### Write the dataframes to the sqlite db. For our case the db is "data.db"
dbWriteTable(con,
"reps",
reps.Dataframe,
append = TRUE,
row.names = FALSE)
dbWriteTable(con,
"product",
product.Dataframe,
append = TRUE,
row.names = FALSE)
dbWriteTable(con,
"customer",
customer.Dataframe,
append = TRUE,
row.names = FALSE)
dbWriteTable(con,
"sales",
sales.Dataframe,
append = TRUE,
row.names = FALSE)
dbWriteTable(
con,
"sales_customer_junction",
junction.Dataframe,
append = TRUE,
row.names = FALSE
)
print('Successfully inserted all data into SQLite!')
dbDisconnect(con)
}
main()
